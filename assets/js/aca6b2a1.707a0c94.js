"use strict";(self.webpackChunkprog_2_web=self.webpackChunkprog_2_web||[]).push([[9797],{3905:(e,a,t)=>{t.d(a,{Zo:()=>p,kt:()=>k});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),d=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},p=function(e){var a=d(e.components);return n.createElement(s.Provider,{value:a},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=d(t),u=r,k=m["".concat(s,".").concat(u)]||m[u]||c[u]||o;return t?n.createElement(k,i(i({ref:a},p),{},{components:t})):n.createElement(k,i({ref:a},p))}));function k(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=t[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},28704:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var n=t(87462),r=(t(67294),t(3905));const o={sidebar_label:"Common Type System",slug:"/clases/introduccion/apuntes/common-type-system",hide_table_of_contents:!1,hide_title:!0,author:"Mauricio Cerizza",authorURL:"https://github.com/mauricioCerizza"},i=void 0,l={unversionedId:"clases/introduccion/Apuntes/common-type-system",id:"clases/introduccion/Apuntes/common-type-system",title:"common-type-system",description:"Common Type System",source:"@site/docs/clases/01-introduccion/Apuntes/03-common-type-system.md",sourceDirName:"clases/01-introduccion/Apuntes",slug:"/clases/introduccion/apuntes/common-type-system",permalink:"/utn-prog-ii/docs/clases/introduccion/apuntes/common-type-system",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/clases/01-introduccion/Apuntes/03-common-type-system.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"Common Type System",slug:"/clases/introduccion/apuntes/common-type-system",hide_table_of_contents:!1,hide_title:!0,author:"Mauricio Cerizza",authorURL:"https://github.com/mauricioCerizza"},sidebar:"Clases",previous:{title:"Introducci\xf3n a C#",permalink:"/utn-prog-ii/docs/clases/introduccion/apuntes/introduccion-c-sharp"},next:{title:"Sentencias de selecci\xf3n",permalink:"/utn-prog-ii/docs/clases/introduccion/apuntes/sentencias-seleccion"}},s={},d=[{value:"Common Type System",id:"common-type-system",level:2},{value:"Tipos de valor y tipos de referencia",id:"tipos-de-valor-y-tipos-de-referencia",level:2},{value:"Categor\xedas de tipos",id:"categor\xedas-de-tipos",level:3},{value:"Aliases",id:"aliases",level:2},{value:"Literales",id:"literales",level:2},{value:"Caracteres",id:"caracteres",level:2},{value:"Strings",id:"strings",level:2},{value:"Tipos num\xe9ricos",id:"tipos-num\xe9ricos",level:2},{value:"Operadores aritm\xe9ticos",id:"operadores-aritm\xe9ticos",level:3},{value:"Operadores de asignaci\xf3n",id:"operadores-de-asignaci\xf3n",level:3},{value:"Enteros",id:"enteros",level:3},{value:"Punto flotante",id:"punto-flotante",level:3},{value:"Decimales",id:"decimales",level:4},{value:"Notaci\xf3n de literales de punto flotante",id:"notaci\xf3n-de-literales-de-punto-flotante",level:4},{value:"Notaci\xf3n binaria y hexadecimal",id:"notaci\xf3n-binaria-y-hexadecimal",level:3},{value:"Tipos booleanos",id:"tipos-booleanos",level:2},{value:"Operadores de igualdad",id:"operadores-de-igualdad",level:3},{value:"Operadores de comparaci\xf3n",id:"operadores-de-comparaci\xf3n",level:3},{value:"Tipo object",id:"tipo-object",level:2},{value:"Tipo dynamic",id:"tipo-dynamic",level:2},{value:"Inferencia de tipos",id:"inferencia-de-tipos",level:2},{value:"Valores por defecto",id:"valores-por-defecto",level:2},{value:"Tama\xf1o de tipos",id:"tama\xf1o-de-tipos",level:2},{value:"Conversiones de tipos de datos",id:"conversiones-de-tipos-de-datos",level:2},{value:"Implicitas",id:"implicitas",level:3},{value:"Explicitas",id:"explicitas",level:3}],p={toc:d},m="wrapper";function c(e){let{components:a,...o}=e;return(0,r.kt)(m,(0,n.Z)({},p,o,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"common-type-system"},"Common Type System"),(0,r.kt)("p",null,"C# por defecto s\xf3lo trae algunas palabras y, estrictamente, no define ning\xfan tipo. Todos los tipos que usamos en C# son provistos por el entorno de .NET. Durante la cursada aprenderemos sobre muchos de los tipos que tenemos disponibles en la plataforma y tambi\xe9n crearemos nuevos."),(0,r.kt)("p",null,"El ",(0,r.kt)("strong",{parentName:"p"},"Common Type System (CTS)")," define un conjunto de tipos de datos com\xfan a todos los lenguajes soportados por .NET. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Establece un marco de herramientas que habilita la ejecuci\xf3n de los distintos lenguajes de la plataforma. "),(0,r.kt)("li",{parentName:"ul"},"Provee un modelo orientado a objetos. "),(0,r.kt)("li",{parentName:"ul"},"Define un conjunto de reglas que todos los lenguajes deben seguir en lo que refiere a tipos."),(0,r.kt)("li",{parentName:"ul"},"Provee una biblioteca que contiene los tipos primitivos b\xe1sicos (Boolean, Int32, Byte, Char, etc). "),(0,r.kt)("li",{parentName:"ul"},"Define tipos de dato en dos categor\xedas: de valor y de referencia.")),(0,r.kt)("h2",{id:"tipos-de-valor-y-tipos-de-referencia"},"Tipos de valor y tipos de referencia"),(0,r.kt)("p",null,"Existen dos segmentos o categor\xedas de memoria: la ",(0,r.kt)("strong",{parentName:"p"},"pila (",(0,r.kt)("em",{parentName:"strong"},"stack memory"),")")," y el ",(0,r.kt)("strong",{parentName:"p"},"mont\xf3n (",(0,r.kt)("em",{parentName:"strong"},"heap memory"),")"),". La memoria stack es m\xe1s r\xe1piida pero limitada en tama\xf1o. La memoria heap es m\xe1s lenta pero m\xe1s abundante."),(0,r.kt)("admonition",{title:"Stack Overflow",type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"La famosa excepci\xf3n Stack Overflow se lanza al llenarse el espacio de la memoria stack, que es muy limitado. Suele suceder cuando se producen llamadas recursivas accidentales o nos encontramos dentro de un loop infinito. ")),(0,r.kt)("p",null,"Los ",(0,r.kt)("strong",{parentName:"p"},"tipos de valor (",(0,r.kt)("em",{parentName:"strong"},"value types"),")")," son tipos de dato representados por su valor real. Si son asignados a una variable, esa variable obtendr\xe1 una nueva copia del valor. ",(0,r.kt)("strong",{parentName:"p"},"Todos los tipos de valor se almacenan en la pila.")," "),(0,r.kt)("p",null,"Los ",(0,r.kt)("strong",{parentName:"p"},"tipos de referencia (",(0,r.kt)("em",{parentName:"strong"},"reference types"),")"),", al contrario, son tipos de dato representados por una referencia que apunta a un sector de memoria donde se encuentra el valor real. Si son asignados a una variable, esa variable almacenar\xe1 la referencia y apuntar\xe1 al valor original. No se realiza ninguna copia del valor. ",(0,r.kt)("strong",{parentName:"p"},"Todos los tipos de referencia se almacenan en el mont\xf3n.")," "),(0,r.kt)("h3",{id:"categor\xedas-de-tipos"},"Categor\xedas de tipos"),(0,r.kt)("p",null,".NET define cinco categor\xedas de tipos de datos."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Categor\xeda"),(0,r.kt)("th",{parentName:"tr",align:null},"Palabra clave"),(0,r.kt)("th",{parentName:"tr",align:null},"Valor/Referencia"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Clases")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"class"))),(0,r.kt)("td",{parentName:"tr",align:null},"Tipo de referencia")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Estructuras")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"struct"))),(0,r.kt)("td",{parentName:"tr",align:null},"Tipo de valor")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Enumerados")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"enum"))),(0,r.kt)("td",{parentName:"tr",align:null},"Tipo de valor")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Interfaces")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"interface"))),(0,r.kt)("td",{parentName:"tr",align:null},"Tipo de referencia")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Delegados")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"delegate"))),(0,r.kt)("td",{parentName:"tr",align:null},"Tipo de referencia")))),(0,r.kt)("p",null,"Entraremos en el detalle de cada una de estas categor\xedas a lo largo de la cursada. "),(0,r.kt)("h2",{id:"aliases"},"Aliases"),(0,r.kt)("p",null,"Algunas de las palabras clave de C# como ",(0,r.kt)("inlineCode",{parentName:"p"},"double"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," son ",(0,r.kt)("strong",{parentName:"p"},"alias (",(0,r.kt)("em",{parentName:"strong"},"aliases"),")")," que representan tipos proveidos por la implementaci\xf3n de la plataforma .NET donde se ejecuta C#. Por ejemplo, ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," es un alias para el tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"System.Int32"),"."),(0,r.kt)("h2",{id:"literales"},"Literales"),(0,r.kt)("p",null,"Los ",(0,r.kt)("strong",{parentName:"p"},"valores literales (",(0,r.kt)("em",{parentName:"strong"},"literal value"),")")," son una notaci\xf3n que representa un valor fijo. Dependiendo el tipo de dato, existe una notaci\xf3n diferente para los literales. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"string saludo = \"Hola Mundo\"; // \"Hola Mundo\" es un literal de texto que se est\xe1 asignando a la variable 'saludo' de tipo string.\n\nint numero = 5; // 5 es un literal num\xe9rico que se est\xe1 asignando a la variable 'numero' de tipo entero.\n")),(0,r.kt)("h2",{id:"caracteres"},"Caracteres"),(0,r.kt)("p",null,"Cuando trabajamos con un caracter individual, como podr\xeda ser una letra, el tipo a utilizar es ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),". "),(0,r.kt)("p",null,"Los literales de este tipo deben estar encerrados por comillas simples ",(0,r.kt)("inlineCode",{parentName:"p"},"'"),"."),(0,r.kt)("p",null,"Los ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," son tipos de valor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"char simbolo = '$';\nchar letra = 'Z';\nchar numero = '1'; // '1' se almacena como tipo char, no es num\xe9rico.\n")),(0,r.kt)("h2",{id:"strings"},"Strings"),(0,r.kt)("p",null,"Cuando trabajamos con texto formado por m\xfaltiples caracteres el tipo a utilizar es ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". "),(0,r.kt)("p",null,"Los literales de este tipo deben estar encerrados por comillas dobles ",(0,r.kt)("inlineCode",{parentName:"p"},'"'),"."),(0,r.kt)("p",null,"Los ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," son tipos de referencia. Internamente son arrays de ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),", incluso pueden ser recorridos con un bucle ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"foreach"),"."),(0,r.kt)("p",null,"Los ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," se pueden concatenar usando el operador ",(0,r.kt)("inlineCode",{parentName:"p"},"+"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'string nombre = "Florencia";\nstring telefono = "(+54) 9 11-12345-15432";\nstring contacto = nombre + " tiene el n\xfamero de tel\xe9fono " + telefono;\n')),(0,r.kt)("h2",{id:"tipos-num\xe9ricos"},"Tipos num\xe9ricos"),(0,r.kt)("p",null,"Los n\xfameros son datos con los que vamos a realizar alguna operaci\xf3n aritm\xe9tica (como sumar o multiplicar). Un DNI, un n\xfamero de tel\xe9fono, un legajo, NO son n\xfameros. "),(0,r.kt)("p",null,"Todos los tipos num\xe9ricos primitivos de C# son tipos de valor."),(0,r.kt)("h3",{id:"operadores-aritm\xe9ticos"},"Operadores aritm\xe9ticos"),(0,r.kt)("p",null,"Los ",(0,r.kt)("strong",{parentName:"p"},"operadores aritm\xe9ticos")," nos permiten realizar operaciones aritm\xe9ticas sobre una o m\xe1s variables num\xe9ricas. "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Operador"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Nombre"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Ejemplo"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Resultado"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Suma"),(0,r.kt)("td",{parentName:"tr",align:"center"},"4 + 2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"6")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Resta"),(0,r.kt)("td",{parentName:"tr",align:"center"},"4 - 2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Multiplicaci\xf3n"),(0,r.kt)("td",{parentName:"tr",align:"center"},"4 * 2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"/")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Divisi\xf3n"),(0,r.kt)("td",{parentName:"tr",align:"center"},"4 / 2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"%")),(0,r.kt)("td",{parentName:"tr",align:"left"},"M\xf3dulo o resto"),(0,r.kt)("td",{parentName:"tr",align:"center"},"4 % 2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"++")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Incremento"),(0,r.kt)("td",{parentName:"tr",align:"center"},"4++"),(0,r.kt)("td",{parentName:"tr",align:"center"},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"--")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Decremento"),(0,r.kt)("td",{parentName:"tr",align:"center"},"4--"),(0,r.kt)("td",{parentName:"tr",align:"center"},"3")))),(0,r.kt)("admonition",{title:"Informaci\xf3n",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Para m\xe1s informaci\xf3n sobre los operadores aritm\xe9ticos, visita la ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators"},"documentaci\xf3n oficial"),".")),(0,r.kt)("h3",{id:"operadores-de-asignaci\xf3n"},"Operadores de asignaci\xf3n"),(0,r.kt)("p",null,"El operador de asignaci\xf3n se puede combinar con los operadores aritm\xe9ticos:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"int numero = 5;\n\nnumero += 2; // Es lo mismo que escribir numero = numero + 2;\nnumero -= 2; // Es lo mismo que escribir numero = numero - 2;\nnumero *= 2; // Es lo mismo que escribir numero = numero * 2;\nnumero /= 2; // Es lo mismo que escribir numero = numero / 2;\n")),(0,r.kt)("h3",{id:"enteros"},"Enteros"),(0,r.kt)("p",null,"El conjunto de ",(0,r.kt)("strong",{parentName:"p"},"n\xfameros reales")," se puede dividir en dos subconjuntos: racionales e irracionales. Los ",(0,r.kt)("strong",{parentName:"p"},"n\xfameros racionales")," son aquellos que pueden expresarse como la divisi\xf3n de dos n\xfameros enteros, los ",(0,r.kt)("strong",{parentName:"p"},"n\xfameros irracionales")," son todos los dem\xe1s. A su vez, el conjunto de los racionales se puede dividir en ",(0,r.kt)("strong",{parentName:"p"},"n\xfameros enteros")," y ",(0,r.kt)("strong",{parentName:"p"},"n\xfameros fraccionarios"),". "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Clasificaci\xf3n de los n\xfameros",src:t(98887).Z,width:"572",height:"268"})),(0,r.kt)("p",null,"Los n\xfameros enteros (sin punto decimal) se representan con los tipos ",(0,r.kt)("inlineCode",{parentName:"p"},"short"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"long"),". Los enteros positivos incluyendo el cero se conocen como ",(0,r.kt)("strong",{parentName:"p"},"n\xfameros naturales")," y se representan con los tipos enteros sin signo (",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"unsigned")),") como ",(0,r.kt)("inlineCode",{parentName:"p"},"ushort"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"uint")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"ulong"),"."),(0,r.kt)("p",null,"Los literales de ",(0,r.kt)("inlineCode",{parentName:"p"},"long")," deben ir acompa\xf1ados del sufijo ",(0,r.kt)("inlineCode",{parentName:"p"},"L"),". Para los enteros no es necesarario un sufijo."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"uint numeroNatural = 10;\n\nint numeroEntero = -5;\n\nlong numeroGrande = 20L;\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Palabra clave"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Rango"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Tama\xf1o"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Tipo en .NET"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"sbyte")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"-128")," a ",(0,r.kt)("em",{parentName:"td"},"127")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 8-bit con signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.SByte"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"byte")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"0")," a ",(0,r.kt)("em",{parentName:"td"},"255")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 8-bit sin signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.Byte"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"short")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"32.768")," a ",(0,r.kt)("em",{parentName:"td"},"32.767")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 16-bit con signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.Int16"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"ushort")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"0")," a ",(0,r.kt)("em",{parentName:"td"},"65.535")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 16-bit sin signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.UInt16"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"-2.147.483.648")," a ",(0,r.kt)("em",{parentName:"td"},"2.147.483.647")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 32-bit con signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.Int32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"uint")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"0")," a ",(0,r.kt)("em",{parentName:"td"},"4.294.967.295")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 32-bit sin signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.UInt32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"long")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"-9.223.372.036.854.775.808")," a ",(0,r.kt)("em",{parentName:"td"},"9.223.372.036.854.775.807")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 64-bit con signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.Int64"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"ulong")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("em",{parentName:"td"},"0")," a ",(0,r.kt)("em",{parentName:"td"},"18.446.744.073.709.551.615")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Entero de 64-bit sin signo"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"System.UInt64"))))),(0,r.kt)("h3",{id:"punto-flotante"},"Punto flotante"),(0,r.kt)("p",null,"Los tipos ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," almacenan n\xfameros reales fraccionarios representados con notaci\xf3n de punto flotante de precisi\xf3n simple y doble, respectivamente. En otras palabras, el tipo de dato ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," tiene una precisi\xf3n dos veces mayor al tipo de dato float."),(0,r.kt)("p",null,"La representaci\xf3n de ",(0,r.kt)("strong",{parentName:"p"},"punto flotante (",(0,r.kt)("em",{parentName:"strong"},"floating point"),")")," es una forma de notaci\xf3n cient\xedfica usada en las computadoras con la cual se pueden representar n\xfameros reales extremadamente grandes y peque\xf1os de una manera muy eficiente y compacta, y con la que se pueden realizar operaciones aritm\xe9ticas. "),(0,r.kt)("h4",{id:"decimales"},"Decimales"),(0,r.kt)("p",null,"Aunque el tipo de dato ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," es bastante preciso, existe un tipo de dato a\xfan m\xe1s preciso, que es el tipo de dato ",(0,r.kt)("inlineCode",{parentName:"p"},"decimal"),". Es m\xe1s preciso porque almacena los n\xfameros como un gran entero y cambia el punto decimal. Por ejemplo ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1")," se almacena como ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," con una nota de cambiar el punto decimal un lugar a la izquierda, ",(0,r.kt)("inlineCode",{parentName:"p"},"12.75")," se almacena como ",(0,r.kt)("inlineCode",{parentName:"p"},"1275")," con una nota de cambiar el punto decimal dos lugares a la izquierda. "),(0,r.kt)("p",null,"Entonces, si requerimos resultados precisos debemos usar ",(0,r.kt)("inlineCode",{parentName:"p"},"decimal"),", sino debemos usar ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," que se procesan con mayor velocidad."),(0,r.kt)("p",null,"El comparar valores de punto flotante con el operador de igualdad puede dar lugar a errores."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'double a = 0.1;\ndouble b = 0.2;\ndouble resultado = a + b;\nbool resultadoEsperado = resultado == 0.3;\n\nConsole.WriteLine("La suma de {0} y {1} da {2}. \xbfResultado esperado? {3}", a, b, resultado, resultadoEsperado);\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"La suma de 0,1 y 0,2 da 0,30000000000000004. \xbfResultado esperado? False\n")),(0,r.kt)("p",null,"En el ejemplo vemos que el resultado de la suma entre ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"0.2")," cuando trabajamos ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," tiene un error de precisi\xf3n y al comparar nos indica que no es igual a ",(0,r.kt)("inlineCode",{parentName:"p"},"0.3"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'decimal a = 0.1M;\ndecimal b = 0.2M;\ndecimal resultado = a + b;\nbool resultadoEsperado = resultado == 0.3M;\n\nConsole.WriteLine("La suma de {0} y {1} da {2}. \xbfResultado esperado? {3}", a, b, resultado, resultadoEsperado);\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"La suma de 0,1 y 0,2 da 0,3. \xbfResultado esperado? True\n")),(0,r.kt)("p",null,"Al trabajar con ",(0,r.kt)("inlineCode",{parentName:"p"},"decimal")," no tenemos estos errores."),(0,r.kt)("admonition",{title:"Advertencia",type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"No se deben comparar valores ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," usando ",(0,r.kt)("inlineCode",{parentName:"p"},"=="),". El tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," no garantiza precisi\xf3n porque existen algunos n\xfameros que no pueden ser representados como valores de punto flotante. "),(0,r.kt)("p",{parentName:"admonition"},"En 1991, durante la primera guerra del golfo, usar n\xfameros de punto flotante ",(0,r.kt)("a",{parentName:"p",href:"https://www-users.cse.umn.edu/~arnold/disasters/patriot.html"},"le cost\xf3 la vida a 28 soldados")," al no poder rastrear e interceptar un misil con precisi\xf3n. ")),(0,r.kt)("admonition",{title:"Buena pr\xe1ctica",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Es una buena pr\xe1ctica usar ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," para n\xfameros enteros y ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," para fraccionarios que no requieran precisi\xf3n y que no ser\xe1n comparados a otros valores. Usar ",(0,r.kt)("inlineCode",{parentName:"p"},"decimal")," para dinero y valores donde la precisi\xf3n es importante. ")),(0,r.kt)("h4",{id:"notaci\xf3n-de-literales-de-punto-flotante"},"Notaci\xf3n de literales de punto flotante"),(0,r.kt)("p",null,"Por defecto los literales fraccionarios (con punto decimal) son de tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"double"),". Los literales de ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," deben ir acompa\xf1ados del sufijo ",(0,r.kt)("inlineCode",{parentName:"p"},"F"),". Los literales de ",(0,r.kt)("inlineCode",{parentName:"p"},"decimal")," deben ir acompa\xf1ados del sufijo ",(0,r.kt)("inlineCode",{parentName:"p"},"M"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"float numeroFlotantePrecisionSimple = 2.5F;\n\ndouble numeroFlotantePrecisionDoble = 2.5;\n\ndecimal numeroDecimal = 2.5M;\n")),(0,r.kt)("h3",{id:"notaci\xf3n-binaria-y-hexadecimal"},"Notaci\xf3n binaria y hexadecimal"),(0,r.kt)("p",null,"C# tambi\xe9n permite escribir literales num\xe9ricos en binario (base 2) y hexadecimal (base 16). Un literal binario debe empezar con ",(0,r.kt)("inlineCode",{parentName:"p"},"0b"),", mientras que uno hexadecimal con ",(0,r.kt)("inlineCode",{parentName:"p"},"0x"),"."),(0,r.kt)("p",null,"Desde C# 7.0 se puede usar el gui\xf3n bajo ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," como separador de digitos con el \xfanico uso de mejorar la legibilidad del n\xfamero. "),(0,r.kt)("p",null,"En el siguiente ejemplo vemos como escribir el valor de dos millones en decimal, binario y hexadecimal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Notaci\xf3n decimal\nint notacionBase10 = 2_000_000; // El _ es una ayuda visual para separar los d\xedgitos. No cumple otra funci\xf3n. \n\n// Notaci\xf3n binaria\nint notacionBase2 = 0b_0001_1110_1000_0100_1000_0000;\n\n// Notaci\xf3n hexadecimal\nint notacionBase16 = 0x_001E_8480;\n")),(0,r.kt)("p",null,"Si comparamos las variables con el operador de igualdad ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," observaremos que, al ser el mismo valor pero expresado con diferentes notaciones, la igualdad es verdadera."),(0,r.kt)("h2",{id:"tipos-booleanos"},"Tipos booleanos"),(0,r.kt)("p",null,"Los tipos booleanos s\xf3lo pueden contener dos valores literales ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," o ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Se usan principalmente en condiciones de bloques de selecci\xf3n  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"bool verdadero = true;\nbool falso = false;\n")),(0,r.kt)("h3",{id:"operadores-de-igualdad"},"Operadores de igualdad"),(0,r.kt)("p",null,"Los ",(0,r.kt)("strong",{parentName:"p"},"operadores de igualdad")," retornan un resultado booleano en base a si los operandos comparados son iguales o distintos. "),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"==")," retornar\xe1 ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," cuando la igualdad se cumpla, de lo contrario ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"!=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," cuando la igualdad NO se cumpla y ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," cuando los operandos sean iguales. "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Operador"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Nombre"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Ejemplo"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Resultado"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Igualdad"),(0,r.kt)("td",{parentName:"tr",align:"center"},'"Programaci\xf3n II" == "Programaci\xf3n II"'),(0,r.kt)("td",{parentName:"tr",align:"center"},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Desigualdad"),(0,r.kt)("td",{parentName:"tr",align:"center"},'"Programaci\xf3n II" != "Laboratorio de Computaci\xf3n II"'),(0,r.kt)("td",{parentName:"tr",align:"center"},"true")))),(0,r.kt)("p",null,"Los tipos de valor son iguales cuando sus valores son iguales. Los tipos de referencia son iguales cuando apuntan a la misma direcci\xf3n de memoria. "),(0,r.kt)("h3",{id:"operadores-de-comparaci\xf3n"},"Operadores de comparaci\xf3n"),(0,r.kt)("p",null,"Los ",(0,r.kt)("strong",{parentName:"p"},"operadores de comparaci\xf3n")," tambi\xe9n retornan un resultado booleano y sirven para comparar valores num\xe9ricos. "),(0,r.kt)("p",null,"Retornar\xe1n ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," cuando la comparaci\xf3n se cumpla, de lo contrario ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Operador"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Nombre"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Ejemplo"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Resultado"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},">")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Mayor que"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4 > 4"),(0,r.kt)("td",{parentName:"tr",align:"center"},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},">=")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Mayor o igual a"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4 >= 4"),(0,r.kt)("td",{parentName:"tr",align:"center"},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"<")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Menor que"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4 < 2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"<=")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Menor o igual a"),(0,r.kt)("td",{parentName:"tr",align:"left"},"2 <= 4"),(0,r.kt)("td",{parentName:"tr",align:"center"},"true")))),(0,r.kt)("h2",{id:"tipo-object"},"Tipo object"),(0,r.kt)("p",null,"Todos los tipos de datos en .NET derivan de un tipo de dato padre, la clase ",(0,r.kt)("inlineCode",{parentName:"p"},"System.Object"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," es un alias de ",(0,r.kt)("inlineCode",{parentName:"p"},"System.Object"),". "),(0,r.kt)("p",null,"Esto nos permite almacenar en una variable de tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," cualquier valor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'object nombre = "Esteban";\nobject promedio = 9.99;\n\nConsole.WriteLine("{0} tiene un promedio de {1}.", nombre, promedio);\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Esteban tiene un promedio de 9,99.\n")),(0,r.kt)("p",null,"Si quisiera acceder a la propiedad ",(0,r.kt)("inlineCode",{parentName:"p"},"Length")," de la variable ",(0,r.kt)("inlineCode",{parentName:"p"},"nombre"),", primero tendr\xe9 que castear el valor a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'object nombre = "Esteban";\nint longitud = ((string) nombre).Length;\n\nConsole.WriteLine("{0} tiene {1} caracteres.", nombre, longitud);\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Esteban tiene 7 caracteres.\n")),(0,r.kt)("p",null,"El operador de casteo ",(0,r.kt)("inlineCode",{parentName:"p"},"(tipo de dato)")," le indica al compilador que el valor de una variable es en realidad de otro tipo. En el ejemplo le indicamos que el valor de ",(0,r.kt)("inlineCode",{parentName:"p"},"nombre")," es de tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". "),(0,r.kt)("p",null,"Una vez realizado el casteo podemos acceder a los atributos y m\xe9todos del tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". "),(0,r.kt)("admonition",{title:"Advertencia",type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"No es una buena pr\xe1ctica usar el tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"object"),". C# es un lenguaje fuertemente tipado y se debe trabajar aprovechando las ventajas de definir tipos de datos concretos, usar ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," afecta la mantenibilidad del c\xf3digo y el rendimiento. ")),(0,r.kt)("h2",{id:"tipo-dynamic"},"Tipo dynamic"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dynamic")," es otro tipo especial que tambi\xe9n puede almacenar cualquier valor. La diferencia con ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," radica en que nos permite utilizar los atributos y m\xe9todos del valor almacenado sin necesidad de un casteo. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'dynamic nombre = "Esteban";\ndynamic promedio = 9.99;\nint longitud = nombre.Length;\n\nConsole.WriteLine("{0} tiene {1} caracteres y un promedio de {2}.", nombre, longitud, promedio);\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Esteban tiene 7 caracteres y un promedio de 9,99.\n")),(0,r.kt)("p",null,"Estos tipos no se validan en tiempo de compilaci\xf3n, sino que lo har\xe1 el CLR durante en tiempo de ejecuci\xf3n. Por este motivo el ",(0,r.kt)("em",{parentName:"p"},"IntelliSense")," de Visual Studio puede no funcionar para estas variables. "),(0,r.kt)("admonition",{title:"Advertencia",type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"No se debe usar el tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic")," salvo que surja una necesidad concreta. El uso de este tipo afecta la mantenibilidad del c\xf3digo y el rendimiento. ")),(0,r.kt)("h2",{id:"inferencia-de-tipos"},"Inferencia de tipos"),(0,r.kt)("p",null,"El modificador ",(0,r.kt)("inlineCode",{parentName:"p"},"var")," sirve para declarar variables para las cuales el tipo de dato ser\xe1 determinado por el valor que se le est\xe1 asignando. Es una caracter\xedstica que nos quita la necesidad de tener que especificar los tipos en las declaraciones, eso s\xed, siempre que estemos asignando alg\xfan valor a la variable. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var producto = "Alfajor Capit\xe1n del Espacio";\n\nConsole.WriteLine("{0} es de tipo {1}", nameof(producto), producto.GetType().Name);\n\nvar capas = 3;\n\nConsole.WriteLine("{0} es de tipo {1}", nameof(capas), capas.GetType().Name);\n\nvar precio = 99.99M;\n\nConsole.WriteLine("{0} es de tipo {1}", nameof(precio), precio.GetType().Name);\n\nvar peso = 40F;\n\nConsole.WriteLine("{0} es de tipo {1}", nameof(peso), peso.GetType().Name);\n\nvar stock = 1000L;\n\nConsole.WriteLine("{0} es de tipo {1}", nameof(stock), stock.GetType().Name);\n\nvar glaseado = true;\n\nConsole.WriteLine("{0} es de tipo {1}", nameof(glaseado), glaseado.GetType().Name);\n\nvar codigoGusto = \'C\';\n\nConsole.WriteLine("{0} es de tipo {1}", nameof(codigoGusto), codigoGusto.GetType().Name);\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"producto es de tipo String\ncapas es de tipo Int32\nprecio es de tipo Decimal\npeso es de tipo Single\nstock es de tipo Int64\nglaseado es de tipo Boolean\ncodigoGusto es de tipo Char\n")),(0,r.kt)("p",null,"El m\xe9todo ",(0,r.kt)("inlineCode",{parentName:"p"},"GetType")," es heredado de la clase ",(0,r.kt)("inlineCode",{parentName:"p"},"System.Object")," para todos los tipos de dato y permite obtener informaci\xf3n en tiempo de ejecuci\xf3n sobre el tipo almacenado en la variable. "),(0,r.kt)("admonition",{title:"Advertencia",type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Algunos desarroladores consideran que usar ",(0,r.kt)("inlineCode",{parentName:"p"},"var")," afecta negativamente la legibilidad del c\xf3digo. ",(0,r.kt)("strong",{parentName:"p"},"Evit\xe1 usarlo durante la cursada."))),(0,r.kt)("h2",{id:"valores-por-defecto"},"Valores por defecto"),(0,r.kt)("p",null,"Por defecto los tipos de valor contienen del valor ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," si son num\xe9ricos, ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," si son de tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"''")," si son de tipo ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),". Por otra parte, si no se inicializan, las variables de tipos de referencia contendr\xe1n el valor ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," que indica que esa variable no apunta a ninguna direcci\xf3n de memoria."),(0,r.kt)("p",null,"El operador ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," recibe como argumento un tipo de dato y nos devuelve el valor por defecto de ese tipo. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'Console.WriteLine("Valor por defecto de enteros: {0}", default(int));\nConsole.WriteLine("Valor por defecto de flotantes: {0}", default(double));\nConsole.WriteLine("Valor por defecto de booleanos: {0}", default(bool));\nConsole.WriteLine("Valor por defecto de fechas: {0}", default(DateTime));\nConsole.WriteLine("Valor por defecto de strings: {0}", default(string));\nConsole.WriteLine("Valor por defecto de chars: {0}", default(char));\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Valor por defecto de enteros: 0\nValor por defecto de flotantes: 0\nValor por defecto de booleanos: False\nValor por defecto de fechas: 1/1/0001 00:00:00\nValor por defecto de strings:\nValor por defecto de chars:\n")),(0,r.kt)("h2",{id:"tama\xf1o-de-tipos"},"Tama\xf1o de tipos"),(0,r.kt)("p",null,"El operador ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof()")," recibe como argumento un tipo de dato y retorna el n\xfamero de bytes que usa ese tipo en memoria. "),(0,r.kt)("p",null,"Adem\xe1s, algunos tipos cuentan con las propiedades ",(0,r.kt)("inlineCode",{parentName:"p"},"MinValue")," y ",(0,r.kt)("inlineCode",{parentName:"p"},"MaxValue")," que retornan el valor m\xednimo y el valor m\xe1ximo que puede almacenar una variable de cierto tipo."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'Console.WriteLine("int usa {0} bytes y soporta un rango de valores entre {1} y {2}.", sizeof(int), int.MinValue, int.MaxValue);\nConsole.WriteLine("double usa {0} bytes y soporta un rango de valores entre {1} y {2}.", sizeof(double), double.MinValue, double.MaxValue);\nConsole.WriteLine("decimal usa {0} bytes y soporta un rango de valores entre {1} y {2}.", sizeof(decimal), decimal.MinValue, decimal.MaxValue);\n')),(0,r.kt)("p",null,"La salida del c\xf3digo anterior es:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int usa 4 bytes y soporta un rango de valores entre -2147483648 y 2147483647.\ndouble usa 8 bytes y soporta un rango de valores entre -1,7976931348623157E+308 y 1,7976931348623157E+308.\ndecimal usa 16 bytes y soporta un rango de valores entre -79228162514264337593543950335 y 79228162514264337593543950335.\n")),(0,r.kt)("h2",{id:"conversiones-de-tipos-de-datos"},"Conversiones de tipos de datos"),(0,r.kt)("h3",{id:"implicitas"},"Implicitas"),(0,r.kt)("p",null,"No interviene el programador (no requieren casteo). "),(0,r.kt)("p",null,"No deber\xedan implicar p\xe9rdida de datos."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Los float pueden almacenar n\xfameros m\xe1s grandes que los int. \n// No hay p\xe9rdida de datos.\n\nfloat entero = 15; \n")),(0,r.kt)("h3",{id:"explicitas"},"Explicitas"),(0,r.kt)("p",null,"Interviene el programador (se quiere un casteo)."),(0,r.kt)("p",null,"Podr\xedan implicar p\xe9rdida de datos."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Los double pueden almacenar n\xfameros m\xe1s grandes que los int. \n// Adem\xe1s los enteros no guardan los decimales.\n// Puede haber p\xe9rdida de datos.\n\nint entero = (int)15.2; \n")))}c.isMDXComponent=!0},98887:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/clasificacion-numeros-8013ffba6287f58d0504c26473bbd9fd.png"}}]);